<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰“ç –å—æ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: Arial, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            margin: 20px 0;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #0a0a1a;
        }
        
        .game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        
        .info-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .coins {
            color: #ffd700;
        }
        
        .level {
            color: #00ff00;
        }
        
        .score {
            color: #00ffff;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }
        
        .game-over h2 {
            margin: 0 0 20px 0;
            color: #ff0000;
        }
        
        .game-over p {
            margin: 10px 0;
        }
        
        .btn {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
        }
        
        .shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }
        
        .shop h2 {
            margin: 0 0 20px 0;
            color: #00ff00;
        }
        
        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: left;
        }
        
        .shop-item h3 {
            margin: 0 0 5px 0;
            color: #00ffff;
        }
        
        .shop-item p {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .shop-item .price {
            color: #ffd700;
            font-weight: bold;
        }
        
        .shop-item .btn {
            float: right;
        }
        
        .power-up {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .power-up.speed {
            background: #ff0000;
            color: white;
        }
        
        .power-up.size {
            background: #00ff00;
            color: black;
        }
        
        .power-up.multi {
            background: #0000ff;
            color: white;
        }
        
        .coin {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>æ‰“ç –å—æ¸¸æˆ</h1>
    
    <div class="game-container">
        <div class="game-info">
            <div class="info-item coins">ğŸ’° é‡‘å¸: <span id="coins">0</span></div>
            <div class="info-item level">ğŸ† ç­‰çº§: <span id="level">1</span></div>
            <div class="info-item score">ğŸ® åˆ†æ•°: <span id="score">0</span></div>
            <button class="btn" onclick="openShop()">å•†åº—</button>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="game-over" id="gameOver">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p>æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span></p>
            <p>æœ€ç»ˆç­‰çº§: <span id="finalLevel">1</span></p>
            <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
        
        <div class="shop" id="shop">
            <h2>å•†åº—</h2>
            <div class="shop-item">
                <h3> paddle é•¿åº¦ +20%</h3>
                <p>å¢åŠ  paddle çš„é•¿åº¦ï¼Œæ›´å®¹æ˜“æ¥ä½çƒ</p>
                <span class="price">ğŸ’° 50</span>
                <button class="btn" onclick="buyUpgrade('paddleSize')">è´­ä¹°</button>
            </div>
            <div class="shop-item">
                <h3> çƒé€Ÿ +10%</h3>
                <p>å¢åŠ çƒçš„é€Ÿåº¦ï¼Œæ›´å¿«æ¸…é™¤ç –å—</p>
                <span class="price">ğŸ’° 75</span>
                <button class="btn" onclick="buyUpgrade('ballSpeed')">è´­ä¹°</button>
            </div>
            <div class="shop-item">
                <h3> å¤šçƒæ¨¡å¼</h3>
                <p>åŒæ—¶å‘å°„å¤šä¸ªçƒ</p>
                <span class="price">ğŸ’° 150</span>
                <button class="btn" onclick="buyUpgrade('multiBall')">è´­ä¹°</button>
            </div>
            <button class="btn" onclick="closeShop()">å…³é—­</button>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            canvas: null,
            ctx: null,
            paddle: {
                x: 350,
                y: 550,
                width: 100,
                height: 15,
                speed: 8,
                color: '#00ffff'
            },
            balls: [
                {
                    x: 400,
                    y: 530,
                    radius: 8,
                    dx: 4,
                    dy: -4,
                    color: '#ffffff'
                }
            ],
            bricks: [],
            powerUps: [],
            coins: [],
            score: 0,
            coinsCollected: 0,
            level: 1,
            lives: 3,
            gameOver: false,
            shopOpen: false,
            upgrades: {
                paddleSize: 1,
                ballSpeed: 1,
                multiBall: 1
            },
            brickRows: 5,
            brickCols: 10
        };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // åˆå§‹åŒ–ç –å—
            createBricks();
            
            // ç›‘å¬é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // ç›‘å¬é¼ æ ‡äº‹ä»¶
            gameState.canvas.addEventListener('mousemove', handleMouseMove);
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop();
        }
        
        // åˆ›å»ºç –å—
        function createBricks() {
            gameState.bricks = [];
            const brickWidth = (gameState.canvas.width - 100) / gameState.brickCols;
            const brickHeight = 30;
            const brickPadding = 10;
            const brickOffsetTop = 80;
            const brickOffsetLeft = 50;
            
            for (let r = 0; r < gameState.brickRows; r++) {
                for (let c = 0; c < gameState.brickCols; c++) {
                    gameState.bricks.push({
                        x: c * (brickWidth + brickPadding) + brickOffsetLeft,
                        y: r * (brickHeight + brickPadding) + brickOffsetTop,
                        width: brickWidth,
                        height: brickHeight,
                        status: 1,
                        color: getBrickColor(r)
                    });
                }
            }
        }
        
        // è·å–ç –å—é¢œè‰²
        function getBrickColor(row) {
            const colors = ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#00ffff'];
            return colors[row % colors.length];
        }
        
        // å¤„ç†é”®ç›˜æŒ‰ä¸‹
        function handleKeyDown(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                gameState.paddle.movingRight = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                gameState.paddle.movingLeft = true;
            } else if (e.key === ' ' && gameState.gameOver) {
                restartGame();
            }
        }
        
        // å¤„ç†é”®ç›˜é‡Šæ”¾
        function handleKeyUp(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                gameState.paddle.movingRight = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                gameState.paddle.movingLeft = false;
            }
        }
        
        // å¤„ç†é¼ æ ‡ç§»åŠ¨
        function handleMouseMove(e) {
            const relativeX = e.clientX - gameState.canvas.offsetLeft;
            if (relativeX > 0 && relativeX < gameState.canvas.width) {
                gameState.paddle.x = relativeX - (gameState.paddle.width * gameState.upgrades.paddleSize) / 2;
            }
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            if (gameState.gameOver || gameState.shopOpen) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // æ¸…ç©ºç”»å¸ƒ
            gameState.ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // ç»˜åˆ¶æ‰€æœ‰å…ƒç´ 
            drawPaddle();
            drawBalls();
            drawBricks();
            drawPowerUps();
            drawCoins();
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            updatePaddle();
            updateBalls();
            updatePowerUps();
            updateCoins();
            
            // æ£€æŸ¥æ¸¸æˆèƒœåˆ©
            checkWin();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ç»˜åˆ¶ paddle
        function drawPaddle() {
            gameState.ctx.beginPath();
            gameState.ctx.rect(
                gameState.paddle.x,
                gameState.paddle.y,
                gameState.paddle.width * gameState.upgrades.paddleSize,
                gameState.paddle.height
            );
            gameState.ctx.fillStyle = gameState.paddle.color;
            gameState.ctx.fill();
            gameState.ctx.closePath();
        }
        
        // ç»˜åˆ¶çƒ
        function drawBalls() {
            gameState.balls.forEach(ball => {
                gameState.ctx.beginPath();
                gameState.ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                gameState.ctx.fillStyle = ball.color;
                gameState.ctx.fill();
                gameState.ctx.closePath();
            });
        }
        
        // ç»˜åˆ¶ç –å—
        function drawBricks() {
            gameState.bricks.forEach(brick => {
                if (brick.status === 1) {
                    gameState.ctx.beginPath();
                    gameState.ctx.rect(brick.x, brick.y, brick.width, brick.height);
                    gameState.ctx.fillStyle = brick.color;
                    gameState.ctx.fill();
                    gameState.ctx.closePath();
                }
            });
        }
        
        // ç»˜åˆ¶ power-up
        function drawPowerUps() {
            gameState.powerUps.forEach(powerUp => {
                gameState.ctx.beginPath();
                gameState.ctx.arc(powerUp.x, powerUp.y, 15, 0, Math.PI * 2);
                gameState.ctx.fillStyle = powerUp.color;
                gameState.ctx.fill();
                gameState.ctx.fillStyle = powerUp.textColor;
                gameState.ctx.font = '12px Arial';
                gameState.ctx.textAlign = 'center';
                gameState.ctx.textBaseline = 'middle';
                gameState.ctx.fillText(powerUp.type, powerUp.x, powerUp.y);
                gameState.ctx.closePath();
            });
        }
        
        // ç»˜åˆ¶é‡‘å¸
        function drawCoins() {
            gameState.coins.forEach(coin => {
                gameState.ctx.beginPath();
                gameState.ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                gameState.ctx.fillStyle = '#ffd700';
                gameState.ctx.fill();
                gameState.ctx.closePath();
            });
        }
        
        // æ›´æ–° paddle
        function updatePaddle() {
            if (gameState.paddle.movingRight && gameState.paddle.x < gameState.canvas.width - (gameState.paddle.width * gameState.upgrades.paddleSize)) {
                gameState.paddle.x += gameState.paddle.speed;
            } else if (gameState.paddle.movingLeft && gameState.paddle.x > 0) {
                gameState.paddle.x -= gameState.paddle.speed;
            }
        }
        
        // æ›´æ–°çƒ
        function updateBalls() {
            gameState.balls.forEach((ball, index) => {
                // ç¢°æ’æ£€æµ‹ - å·¦å³å¢™å£
                if (ball.x + ball.dx > gameState.canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                    ball.dx = -ball.dx;
                }
                
                // ç¢°æ’æ£€æµ‹ - ä¸Šå¢™å£
                if (ball.y + ball.dy < ball.radius) {
                    ball.dy = -ball.dy;
                }
                
                // ç¢°æ’æ£€æµ‹ - paddle
                if (ball.y + ball.dy > gameState.paddle.y - ball.radius && 
                    ball.y + ball.dy < gameState.paddle.y + gameState.paddle.height && 
                    ball.x > gameState.paddle.x && 
                    ball.x < gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize)) {
                    // è®¡ç®—ç¢°æ’ç‚¹ï¼Œä½¿çƒçš„åå¼¹è§’åº¦ä¸ç¢°æ’ä½ç½®æœ‰å…³
                    const hitPos = (ball.x - (gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize) / 2)) / 
                                   ((gameState.paddle.width * gameState.upgrades.paddleSize) / 2);
                    const angle = hitPos * Math.PI / 3; // æœ€å¤§60åº¦è§’
                    ball.dx = gameState.upgrades.ballSpeed * 4 * Math.sin(angle);
                    ball.dy = -gameState.upgrades.ballSpeed * 4 * Math.cos(angle);
                }
                
                // ç¢°æ’æ£€æµ‹ - ç –å—
                gameState.bricks.forEach(brick => {
                    if (brick.status === 1) {
                        if (ball.x > brick.x && 
                            ball.x < brick.x + brick.width && 
                            ball.y > brick.y && 
                            ball.y < brick.y + brick.height) {
                            ball.dy = -ball.dy;
                            brick.status = 0;
                            gameState.score += 10;
                            updateScore();
                            
                            // éšæœºç”Ÿæˆ power-up
                            if (Math.random() > 0.8) {
                                createPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                            }
                            
                            // éšæœºç”Ÿæˆé‡‘å¸
                            if (Math.random() > 0.6) {
                                createCoin(brick.x + brick.width / 2, brick.y + brick.height / 2);
                            }
                        }
                    }
                });
                
                // çƒå‡ºç•Œ
                if (ball.y + ball.dy > gameState.canvas.height - ball.radius) {
                    gameState.balls.splice(index, 1);
                    if (gameState.balls.length === 0) {
                        gameState.lives--;
                        if (gameState.lives <= 0) {
                            endGame();
                        } else {
                            resetBall();
                        }
                    }
                }
                
                // æ›´æ–°çƒä½ç½®
                ball.x += ball.dx;
                ball.y += ball.dy;
            });
        }
        
        // æ›´æ–° power-up
        function updatePowerUps() {
            gameState.powerUps.forEach((powerUp, index) => {
                powerUp.y += 2;
                
                // ç¢°æ’æ£€æµ‹ - paddle
                if (powerUp.y + 15 > gameState.paddle.y && 
                    powerUp.y - 15 < gameState.paddle.y + gameState.paddle.height && 
                    powerUp.x > gameState.paddle.x && 
                    powerUp.x < gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize)) {
                    applyPowerUp(powerUp.type);
                    gameState.powerUps.splice(index, 1);
                }
                
                // å‡ºç•Œ
                if (powerUp.y > gameState.canvas.height) {
                    gameState.powerUps.splice(index, 1);
                }
            });
        }
        
        // æ›´æ–°é‡‘å¸
        function updateCoins() {
            gameState.coins.forEach((coin, index) => {
                coin.y += 1.5;
                
                // ç¢°æ’æ£€æµ‹ - paddle
                if (coin.y + 10 > gameState.paddle.y && 
                    coin.y - 10 < gameState.paddle.y + gameState.paddle.height && 
                    coin.x > gameState.paddle.x && 
                    coin.x < gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize)) {
                    gameState.coinsCollected += 1;
                    updateCoinsDisplay();
                    gameState.coins.splice(index, 1);
                }
                
                // å‡ºç•Œ
                if (coin.y > gameState.canvas.height) {
                    gameState.coins.splice(index, 1);
                }
            });
        }
        
        // åˆ›å»º power-up
        function createPowerUp(x, y) {
            const types = ['speed', 'size', 'multi'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let color, textColor, displayText;
            switch (type) {
                case 'speed':
                    color = '#ff0000';
                    textColor = '#ffffff';
                    displayText = 'S';
                    break;
                case 'size':
                    color = '#00ff00';
                    textColor = '#000000';
                    displayText = 'P';
                    break;
                case 'multi':
                    color = '#0000ff';
                    textColor = '#ffffff';
                    displayText = 'M';
                    break;
            }
            
            gameState.powerUps.push({
                x: x,
                y: y,
                type: type,
                color: color,
                textColor: textColor,
                displayText: displayText
            });
        }
        
        // åˆ›å»ºé‡‘å¸
        function createCoin(x, y) {
            gameState.coins.push({
                x: x,
                y: y
            });
        }
        
        // åº”ç”¨ power-up
        function applyPowerUp(type) {
            switch (type) {
                case 'speed':
                    gameState.balls.forEach(ball => {
                        ball.dx *= 1.2;
                        ball.dy *= 1.2;
                    });
                    break;
                case 'size':
                    if (gameState.upgrades.paddleSize < 1.5) {
                        gameState.upgrades.paddleSize += 0.2;
                    }
                    break;
                case 'multi':
                    // æ·»åŠ é¢å¤–çš„çƒ
                    for (let i = 0; i < 2; i++) {
                        gameState.balls.push({
                            x: gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize) / 2,
                            y: gameState.paddle.y - 10,
                            radius: 8,
                            dx: 4 * (Math.random() > 0.5 ? 1 : -1),
                            dy: -4,
                            color: '#ffffff'
                        });
                    }
                    break;
            }
        }
        
        // æ£€æŸ¥èƒœåˆ©
        function checkWin() {
            const remainingBricks = gameState.bricks.filter(brick => brick.status === 1).length;
            if (remainingBricks === 0) {
                // è¿›å…¥ä¸‹ä¸€å…³
                gameState.level++;
                gameState.brickRows = Math.min(8, gameState.brickRows + 1);
                gameState.brickCols = Math.min(12, gameState.brickCols + 1);
                createBricks();
                resetBall();
                updateLevel();
            }
        }
        
        // é‡ç½®çƒ
        function resetBall() {
            gameState.balls = [{
                x: gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize) / 2,
                y: gameState.paddle.y - 10,
                radius: 8,
                dx: 4 * gameState.upgrades.ballSpeed,
                dy: -4 * gameState.upgrades.ballSpeed,
                color: '#ffffff'
            }];
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalLevel').textContent = gameState.level;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            gameState.score = 0;
            gameState.coinsCollected = 0;
            gameState.level = 1;
            gameState.lives = 3;
            gameState.gameOver = false;
            gameState.brickRows = 5;
            gameState.brickCols = 10;
            gameState.upgrades = {
                paddleSize: 1,
                ballSpeed: 1,
                multiBall: 1
            };
            
            updateScore();
            updateCoinsDisplay();
            updateLevel();
            
            createBricks();
            resetBall();
            
            document.getElementById('gameOver').style.display = 'none';
        }
        
        // æ‰“å¼€å•†åº—
        function openShop() {
            gameState.shopOpen = true;
            document.getElementById('shop').style.display = 'block';
        }
        
        // å…³é—­å•†åº—
        function closeShop() {
            gameState.shopOpen = false;
            document.getElementById('shop').style.display = 'none';
        }
        
        // è´­ä¹°å‡çº§
        function buyUpgrade(type) {
            let price;
            switch (type) {
                case 'paddleSize':
                    price = 50;
                    if (gameState.coinsCollected >= price && gameState.upgrades.paddleSize < 1.5) {
                        gameState.coinsCollected -= price;
                        gameState.upgrades.paddleSize += 0.2;
                        updateCoinsDisplay();
                    }
                    break;
                case 'ballSpeed':
                    price = 75;
                    if (gameState.coinsCollected >= price && gameState.upgrades.ballSpeed < 1.5) {
                        gameState.coinsCollected -= price;
                        gameState.upgrades.ballSpeed += 0.2;
                        gameState.balls.forEach(ball => {
                            ball.dx *= 1.2;
                            ball.dy *= 1.2;
                        });
                        updateCoinsDisplay();
                    }
                    break;
                case 'multiBall':
                    price = 150;
                    if (gameState.coinsCollected >= price && gameState.upgrades.multiBall < 3) {
                        gameState.coinsCollected -= price;
                        gameState.upgrades.multiBall++;
                        // æ·»åŠ é¢å¤–çš„çƒ
                        for (let i = 0; i < gameState.upgrades.multiBall - 1; i++) {
                            gameState.balls.push({
                                x: gameState.paddle.x + (gameState.paddle.width * gameState.upgrades.paddleSize) / 2,
                                y: gameState.paddle.y - 10,
                                radius: 8,
                                dx: 4 * (Math.random() > 0.5 ? 1 : -1),
                                dy: -4,
                                color: '#ffffff'
                            });
                        }
                        updateCoinsDisplay();
                    }
                    break;
            }
        }
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScore() {
            document.getElementById('score').textContent = gameState.score;
        }
        
        // æ›´æ–°é‡‘å¸æ˜¾ç¤º
        function updateCoinsDisplay() {
            document.getElementById('coins').textContent = gameState.coinsCollected;
        }
        
        // æ›´æ–°ç­‰çº§æ˜¾ç¤º
        function updateLevel() {
            document.getElementById('level').textContent = gameState.level;
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        window.onload = initGame;
    </script>
</body>
</html>
